[{"content":"","date":"2022-03-24T23:39:34+08:00","permalink":"https://nipabupa.github.io/post/python/dearpygui/","title":"Python Imgui框架：Dearpygui"},{"content":"博主的终端以及neovim配置框架，个人感觉很好用，windows与Mac/Linux都OK。\n仓库地址\n安装 一、终端安装与配置 Unix 使用喜欢的终端即可，Mac推荐Item2\nshell推荐zsh + oh-my-zsh，配置方式官网很详细\nWindows  Windows Terminal + powershell + oh-my-posh，参考   Termianl官网 oh-my-posh官网  Windows Terminal + WSL + oh-my-zsh，参考Unix就行了  PS: 一定要用WindowsTerminal，不然会显示异常，至于shell的话随意\n二、字体选择 基础原则为选择Nerd Font字体\n但是目前发现部分Nerd Font字体对于Neovim中部分组件（比如Telescope.nvim）的边框渲染存在问题，因此需要根据个人喜好选择。\n这里推荐两款: DejaVuSans、Hack\n三、终端工具 直接在Github下载可执行文件至指定目录并配置环境变量即可(或者通过包管理器安装，爱咋咋)\n fd，必要 ripgrep，必要 bat fzf gitui glow  四、LSP Server与NodeJS NodeJS与NPM是可选项，主要是由于很多LSP Server是基于NPM包发布的，需要使用NPM安装\n具体可以参考neovim-lspconfig: LSP配置\n五、Neovim安装 直接从Github下载然后配置环境变量就行了，当然你的包管理器能搜到直接通过包管理器也行，版本\u0026gt;=0.6.0\n六、GCC全家桶 Unix下就不说了，一般都自带，没有就自己安装下\nWindows下需要下载mingw64，然后配置个环境变量\n六、配置 一下给出了Unix下如何下载配置myterm，windows上的话可以参考注释手动执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  cd ~ # 下载代码 git clone https://gitee.com/dingor/myterm.git # 建个软连接至stdpath(\u0026#39;config\u0026#39;) ln -s ~/myterm/nvim ~/.config/nvim # 下载nvim包管理器packer至stdpath(\u0026#39;data\u0026#39;) git clone https://github.com/wbthomason/packer.nvim ~/.local/share/nvim/site/pack/packer/start/packer.nvim # 把nvim加入环境变量，打开nvim # 打开neovim，treesisster会自动下载编译对应的解析器，发现左下角有downloading或compiling就稍等一会，会依赖gcc系统，注意提前下载 nvim # 下载所有插件 :PackerSync # 编译一下 :PackerCompile # 重新启动下nvim, 完成 nvim   使用 基础的操作就不说了，一下仅说下插件配置与一些特殊的配置\n常用工具 一、插件 ","date":"2022-03-21T00:41:28+08:00","permalink":"https://nipabupa.github.io/post/nvim/myterm/","title":"Myterm安装与配置"},{"content":"概念 在不改变原有代码的情况下，为被装饰的对象附加新的功能、附加限制条件或改变输出\n类型：\n 函数装饰器 类装饰器  原理 开发封闭原则，利用闭包的特性，完成被装饰对象的隐式替换。\n举个栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import functools # 定义一个辅助打印日志的装饰器 def log(func): @functools.wraps(func) def inner(): print(\u0026#39;log start\u0026#39;) func() print(\u0026#39;log end\u0026#39;) return inner @log def hello(): print(\u0026#39;hello\u0026#39;) hello()   输出结果:\n1 2 3  log start hello log end   执行顺序\n 系统读取装饰器定义并生成对应的函数对象 当遇到@时，执行后面对应标识符的装饰器函数（若对应标识符为一个函数有参数，则先执行该函数获取返回字符串，执行该字符串对应的装饰器函数） 执行装饰器函数时，将被装饰对象（此处为hello函数对象，可以理解为指针）传递给装饰器函数 装饰器函数执行闭包的逻辑，将原对象进行二次加工，返回加工后的对象  结果经过装饰器修饰，实际执行的hello函数已经是被装饰器替换后的函数，因此具有新的功能\n由于被修饰的对象已经不是原有的对象，因此通过hello.__name__获取到的实际是inner，与我们预期不符，因此通过增加@functools.warps(func)，来解决这些副作用。\n","date":"2022-03-21T00:39:59+08:00","permalink":"https://nipabupa.github.io/post/python/decorator/","title":"Python装饰器"},{"content":"概念 闭包是具体特殊作用域的函数，它在函数定义体中引用了不在定义体中的非全局变量。\n 函数式编程的重要的语法结构 一种组织代码的结构 提高了代码的可重复使用性  条件  必须有一个内部函数 内部函数必须引用外部函数的变量 外部函数的返回值必须是内部函数本身  举个栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def out(): a = [] def inner(): a.append(\u0026#39;test\u0026#39;) print(a) return inner out_ins = out() out_ins() out_ins() out_ins() out_ins2 = out() out_ins2() out_ins2() out_ins2()   返回结果\n1 2 3 4 5 6  [\u0026#39;test\u0026#39;] [\u0026#39;test\u0026#39;, \u0026#39;test\u0026#39;] [\u0026#39;test\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;test\u0026#39;] [\u0026#39;test\u0026#39;] [\u0026#39;test\u0026#39;, \u0026#39;test\u0026#39;] [\u0026#39;test\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;test\u0026#39;]   原理 闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定\n实质上即为每一个闭包函数实例都有一个或多个独属于自己的内部的静态变量。\nnolocal关键字 若闭包内部函数需要对外部函数的变量进行赋值，需要使用nolocal声明外部变量，然后赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def out(): a = [] def inner(): # 若不使用nolocal，则变量a即为inner函数的内部变量，与out函数定义的变量a无任何关系 # 若使用nolocal，则变量a即为out函数定义的变量a nonlocal a a = [\u0026#39;test\u0026#39;] print(a) return inner out_ins = out() out_ins() out_ins2 = out() out_ins2()   返回结果\n1 2  [\u0026#39;test\u0026#39;] [\u0026#39;test\u0026#39;]   ","date":"2022-03-21T00:39:34+08:00","permalink":"https://nipabupa.github.io/post/python/closure/","title":"Python闭包"},{"content":"基本概念  Red Hat Linux发行版专门用来管理Linux各项套件的程序 CentOS、RedHat、Feora、Suse等多种linux发行版均使用 类似于windows的exe安装包  常用命令 1 2 3 4 5 6 7 8 9 10 11 12  # 安装rpm包 rpm -ivh xxx # 升级rpm包 rpm -uvh xxx # 卸载rpm包 rpm -e xxx # 查看当前已安装的rpm包 rpm -qa # 查看当前文件属于哪个rpm包 rpm -qf xxx # 查看当前rpm包有哪些文件 rpm -qpl xxx   制作RPM包  源码包（资源）： xxx.tar.gz spec文件（规则）：xxx.spec  在/root目录下创建如下目录格式\n1 2 3 4 5 6 7  rpmbuild ├── BUILD # 构建目录 ├── BUILDROOT # 构建根目录 ├── SRPMS # 生成的src RPM包存放位置 ├── RPMS # 生成的RPM存放位置 ├── SOURCES # 源文件，补丁文件等存放位置 └── SPECS # 构建目录   将spec脚本与源码包放在对应目录后，执行如下命令：\n1  rpmbuild -ba xxx.spec   Spce脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  Name: Summary: Version: Release: Copyright: Group: License: Source: Source.tar.gz Patch: Require: %prep rpm安装前执行的脚本 %preun rpm卸载前执行的脚本 %setup 解压源码包 %patch 通常补丁都会一起在源码包中，或放到SOURCES目录下。 %build 编译源码构建包 %install 把软件安装到虚拟的根目录中 %clean 清除编译和安装时生成的临时文件 %post rpm安装后执行的脚本 %postun rpm卸载后执行的脚本 %files 文件段，用于定义构成软件包的文件列表，即哪些文件或目录会放入rpm中   ","date":"2022-03-21T00:31:24+08:00","permalink":"https://nipabupa.github.io/post/linux/rpm/","title":"RPM软件包管理"},{"content":"基本概念 yum是一个软件包管理工具\n Fedora、RedHat以及CentOS中使用 基于RPM包 从yum源上自动下载软件包 自动处理依赖性关系 一次安装所有依赖的软件包  常用命令 1 2 3 4 5 6 7 8  # 安装软件包 yum install xxx # 卸载软件包 yum remove xxx # 清理yum源本地缓存 yum clean all # 重新生成yum源本地缓存 yum makecache   yum源 配置 配置目录 /etc/yum.repos.d/，该目录下每一个.repo文件都被识别为yum源的配置，可以配置多个yum源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  [base] name=CentOS-$releasever - Base #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026amp;arch=$basearch\u0026amp;repo=os baseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 #released updates [updates] name=CentOS-$releasever - Updates #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026amp;arch=$basearch\u0026amp;repo=updates baseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that may be useful [extras] name=CentOS-$releasever - Extras #mirrorlist=http://mirrorlist.centos.org/?release=$releasever\u0026amp;arch=$basearch\u0026amp;repo=extras baseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus baseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7   使用ISO作为yum源  将ISO挂载到光驱 将光驱挂载到目录  1 2  mkdir /root/iso mount /dev/sr0 /root/iso   修改yum配置文件  1 2 3 4 5 6 7  vim /etc/yum.repos.d/local.repo [local] name=local baseurl=file:///root/iso/ gpgcheck=0 enabled=1   生成yum源缓存  1 2  yum clean all yum makecache   ","date":"2022-03-21T00:29:29+08:00","permalink":"https://nipabupa.github.io/post/linux/yum/","title":"YUM软件包管理"},{"content":" 参考 ArchLinux Wiki\n 下载ArchLinux官方镜像 ArchLinux官方网站\n制作启动U盘 启动U盘根据操作系统自行选择工具制作\n Win: UtralISO Mac: balena Etcher / dd命令 Linux: dd命令  安装ArchLinux 重启UEFI引导进入ISO镜像分区\n基础配置 键盘 默认为美式键盘，国内的键盘大部分都是美式键盘，可以不用配置。\n1 2 3 4  # 查看可使用的键盘布局 ls /usr/share/kbd/keymaps/**/*.map.gz # 加载指定的键盘布局 loadkeys xxx   网络  有线网：路由器直连无需配置，网络自动联通 无线网：参考iwctl  时间 1 2  timedatectl set-timezone Asia/Shanghai timedatectl set-ntp true   配置磁盘  查看当前的硬盘分区信息  1 2 3 4 5 6 7 8 9 10 11 12  lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT nvme0n1 259:0 0 465.8G 0 disk # 我的硬盘 ├─nvme0n1p1 259:1 0 99M 0 part # Win10 EFI分区 ├─nvme0n1p2 259:2 0 128M 0 part # Win10 不造啥分区 ├─nvme0n1p3 259:3 0 99.4G 0 part # Win10 C盘 ├─nvme0n1p4 259:4 0 577M 0 part # Win10 不造啥分区 ├─nvme0n1p5 259:5 0 50G 0 part # Win10 D盘 ├─nvme0n1p6 259:6 0 215.5G 0 part # Win10 E盘 ├─nvme0n1p7 259:7 0 512M 0 part /boot/EFI # ArchLinux EFI分区 -- 即将创建的分区 ├─nvme0n1p8 259:8 0 40G 0 part / # ArchLinux 根分区 -- 即将创建的分区 └─nvme0n1p9 259:9 0 59.5G 0 part /home # ArchLinux home分区 -- 即将创建的分区   创建分区   若安装盘为一整个硬盘，可以直接删除磁盘上的所有残留分区，重新进行分区 若安装盘为一个硬盘的部分（比如我的硬盘已经安装了Win10），则根据情况删除不需要的分区或者使用空闲空间（空闲空间可以从Win10上压缩一部分）  最终创建上述3个分区即可，其中EFI分区大小512M，其余两个根据需要配置，根分区不小与20G\n1  fdisk /dev/nvme0n1 # 用法自己查   格式化分区  1 2 3  mkfs.vfat /dev/nvme0n1p7 # EFI分区格式为vfat mkfs.ext4 /dev/nvme0n1p8 # 根分区格式为ext4 mkfs.ext4 /dev/nvme0n1p9 # 家分区格式为ext4   挂载分区  1 2 3 4 5  mount /dev/nvme0n1p8 /mnt mkdir -p /mnt/boot/EFI mkdir -p /mnt/home mount /dev/nvme0n1p7 /mnt/boot/EFI mount /dev/nvme0n1p9 /mnt/home   配置Pacman源 修改/etc/pacman.d/mirrorlist在软件源列表最上方添加国内的源\n 163： http://mirrors.163.com/archlinux/$repo/os/$arch 清华： http://mirrors.tuna.tsing.edu.cn/archlinux/$repo/os/$arch  安装基础操作系统 1  pacstrap /mnt base linux linux-firmware   生成分区表 1  genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab   切换根分区 1  arch-chroot /mnt   时区 1 2  ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc   语言 编辑/etc/locale.gen, 去掉en_US.UTF-8的注释\n1  locale-gen   编辑/etc/vconsole.conf，添加LANG=en_US.UTF-8\n修改root密码 1  passwd   安装必须的软件包 使用pamman安装如下软件包 CPU\n1  pacman -S xxx xxx xxx ...      软件包或软件包组(我总觉得不太全，看情况自己装叭)     vim   base-devel   dhcpcd   net-tools   dnsutils   inetutils   iproute2   NetworkManager   intel-ucode    配置引导 1 2 3 4 5 6 7 8 9 10  # 安装引导软件 pacman -S grub efimanager os-prober # 如果你有Windows mkdir /boot/EFI/EFI-WIN # 挂载Windows的EFI分区 mount /dev/nvme0n1p1 /boot/EFI/EFI-WIN # 生成引导 grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootleader-id=ArchLinux # 生成启动配置 grub-mkconfig -o /boot/grub/grub.cfg   退出重启 1 2 3  exit umount -R /mnt reboot   至此ArchLinux安装完成，重启后进入grub界面，选择ArchLinux进入archlinux，选择windows boot manager进入Windows\nKDE 创建用户 1 2 3  groupadd mygroup useradd myname -m -d /home/myname passwd myname   安装KDE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #基础包 pacman-Sxorgxorg-serve pacman-Ssddmkde-applicationssddm-kcm #（可选）集显驱动 pacman-Sxf86-video-intel#intel pacman-Sxf86-video-ati#amd #（可选）Nvidia驱动 pacman-Snvidia #声音 pacman-Salsa-utilspulseaudiopulseaudio-alsa #自启动 systemctlenablesddm systemctlenableNetworkManager systemctlenabledhcpcd   配置 输入法 1 2 3 4 5 6 7 8  pacman -S fcitx fcitx-im fcitx-configtool yay -S fcitx-sogoupingyin vim /home/myusername/.xprofile # 添加 export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=\u0026#34;@im=fcitx\u0026#34;   oh-my-zsh 1 2  pacman -S zsh sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34;   主题ys\nneofetch 1  pacman -S neofetch   全局主题 使用WhiteSur\ndock面板 1  pacman -S latte-dock   最终效果 ","date":"2022-03-21T00:29:24+08:00","permalink":"https://nipabupa.github.io/post/linux/archlinux/","title":"Archlinux安装"}]